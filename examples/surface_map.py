#!/usr/bin/env python3
"""
Example: Surface Map and Heightmap Generator

This example iterates over all region files in a given folder and generates two PNG images:
1. A surface map where each pixel corresponds to the highest block at that position
2. A heightmap where each pixel's brightness corresponds to the height of the highest block

Install requirements with:
pip install pillow numpy
"""

import argparse
import json
import os
import struct
import time
from collections import defaultdict
from concurrent.futures import ProcessPoolExecutor, as_completed
from functools import lru_cache
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from hytale_region_parser.models import ChunkSectionData
import numpy as np
from PIL import Image

from hytale_region_parser import RegionFileParser


# The color_map.json file was generated by getting the avg color from all png files in the games assets directory
with open(Path(__file__).parent / "data" / "color_map.json", "r") as f:
    BLOCK_COLORS = json.load(f)

CUSTOM_BLOCK_COLORS = {
    "Plant_Seaweed": "#176C17",
    "Plant_Crop": "#DBC608",
    "Plant_Leaves": "#1A761A",
    "Plant": "#228B22",
    "Deco_Bone": "#DDDDDD",
    "Deco": "#613D03",
}

BLOCK_COLORS.update(CUSTOM_BLOCK_COLORS)

# Default color for unknown blocks
DEFAULT_COLOR = "#808080"


def parse_hex_color(hex_color: str) -> Tuple[int, int, int]:
    """
    Parse a hex color string (#RRGGBB) to an RGB tuple.
    
    Args:
        hex_color: Hex color string (e.g., "#ff0000")
        
    Returns:
        RGB tuple (r, g, b)
    """
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))


@lru_cache(maxsize=4096)
def get_block_color(block_name: str) -> Tuple[int, int, int]:
    """
    Get the color for a block based on its name.
    Results are cached for performance.
    
    Args:
        block_name: The name of the block
        
    Returns:
        RGB tuple for the block color
    """
    block_name = block_name.strip("*")
    
    # Try exact match first
    if block_name in BLOCK_COLORS:
        return parse_hex_color(BLOCK_COLORS[block_name])
    
    # Try removing parts until a match is found
    part_count = block_name.count("_") + 1
    for maxparts in range(part_count, 0, -1):
        parts = block_name.split("_")
        truncated_name = "_".join(parts[:maxparts])
        if truncated_name in BLOCK_COLORS:
            return parse_hex_color(BLOCK_COLORS[truncated_name])

    print(f"Unknown block: {block_name}")
    
    return parse_hex_color(DEFAULT_COLOR)

def decode_block_at_index(
    section_data: "ChunkSectionData",
    block_idx: int
) -> Optional[str]:
    """
    Decode the block name at a specific index within a section.
    
    Args:
        section_data: The chunk section data
        block_idx: Block index within the section (0-32767)
        
    Returns:
        Block name or None if empty/invalid
    """
    if not section_data.block_indices or not section_data.block_palette:
        return None
    
    # Build internal ID -> block name lookup
    id_to_name = {entry.internal_id: entry.name for entry in section_data.block_palette}
    
    indices = section_data.block_indices
    palette_type = section_data.palette_type
    
    try:
        if palette_type == 0:  # Empty section
            return None
        elif palette_type == 1:  # HalfByte (4 bits per block)
            byte_idx = block_idx // 2
            if byte_idx >= len(indices):
                return None
            byte_val = indices[byte_idx]
            if block_idx % 2 == 0:
                internal_id = byte_val & 0x0F
            else:
                internal_id = (byte_val >> 4) & 0x0F
            return id_to_name.get(internal_id)
        elif palette_type == 2:  # Byte
            if block_idx >= len(indices):
                return None
            internal_id = indices[block_idx]
            return id_to_name.get(internal_id)
        elif palette_type == 3:  # Short (2 bytes per block)
            byte_offset = block_idx * 2
            if byte_offset + 2 > len(indices):
                return None
            internal_id = struct.unpack('>H', indices[byte_offset:byte_offset + 2])[0]
            return id_to_name.get(internal_id)
    except Exception:
        pass
    
    return None


def process_region_file(
    region_path: Path,
) -> Tuple[Dict[Tuple[int, int], Tuple[str, int]], int, int, int, int, int]:
    """
    Process a single region file and return surface data.
    
    Args:
        region_path: Path to the region file
        
    Returns:
        Tuple of (surface_data, min_x, min_z, max_x, max_z, chunks_processed)
    """
    surface_data: Dict[Tuple[int, int], Tuple[str, int]] = {}
    min_x = float('inf')
    min_z = float('inf')
    max_x = float('-inf')
    max_z = float('-inf')
    chunks_processed = 0
    
    with RegionFileParser(region_path) as parser:
        for chunk in parser.iter_chunks():
            chunk_base_x = chunk.chunk_x * 32
            chunk_base_z = chunk.chunk_z * 32
            
            # Update coordinate bounds
            min_x = min(min_x, chunk_base_x)
            min_z = min(min_z, chunk_base_z)
            max_x = max(max_x, chunk_base_x + 31)
            max_z = max(max_z, chunk_base_z + 31)
            
            # Process each section from top to bottom to find highest blocks
            # Sort sections by Y (highest first)
            sorted_sections = sorted(chunk.sections, key=lambda s: -s.section_y)
            
            for section in sorted_sections:
                section_base_y = section.section_y * 32
                
                # Skip empty sections
                if section.palette_type == 0:
                    continue
                
                # Process each column (x, z) in this section
                for local_x in range(32):
                    for local_z in range(32):
                        world_x = chunk_base_x + local_x
                        world_z = chunk_base_z + local_z
                        
                        # Skip if we already have a higher block at this position
                        if (world_x, world_z) in surface_data:
                            existing_height = surface_data[(world_x, world_z)][1]
                            if existing_height >= section_base_y + 32:
                                continue
                        
                        # Check blocks in this column from top to bottom
                        for local_y in range(31, -1, -1):
                            block_idx = local_x + local_z * 32 + local_y * 32 * 32
                            block_name = decode_block_at_index(section, block_idx)
                            
                            if block_name and block_name != "Empty":
                                world_y = section_base_y + local_y
                                
                                # Update if this is higher than existing
                                if (world_x, world_z) not in surface_data or \
                                   world_y > surface_data[(world_x, world_z)][1]:
                                    surface_data[(world_x, world_z)] = (block_name, world_y)
                                break
            
            chunks_processed += 1
    
    return surface_data, min_x, min_z, max_x, max_z, chunks_processed


def generate_maps(
    chunks_folder: Path,
    output_prefix: str = "map"
) -> Tuple[Optional[Path], Optional[Path]]:
    """
    Generate surface map and heightmap from all region files in a folder.
    
    Args:
        chunks_folder: Path to the folder containing .region.bin files
        output_prefix: Prefix for output PNG files
        
    Returns:
        Tuple of (surface_map_path, heightmap_path) or (None, None) on failure
    """
    # Find all region files
    region_files = list(chunks_folder.glob("*.region.bin"))
    
    
    if not region_files:
        print(f"No .region.bin files found in {chunks_folder}")
        return None, None
    
    print(f"Found {len(region_files)} region file(s)")

    # Order by size
    region_files.sort(key=lambda f: f.stat().st_size, reverse=True)
    
    # Dictionary to store highest block at each (x, z) position
    # Key: (world_x, world_z), Value: (block_name, height)
    surface_data: Dict[Tuple[int, int], Tuple[str, int]] = {}
    
    # Track coordinate bounds
    min_x = float('inf')
    min_z = float('inf')
    max_x = float('-inf')
    max_z = float('-inf')
    
    total_chunks = 0
    
    # Calculate number of workers (80% of CPU cores)
    num_workers = max(1, int(os.cpu_count() * 0.8))
    print(f"Using {num_workers} parallel workers")
    
    t1 = time.time()
    
    # Process region files in parallel
    with ProcessPoolExecutor(max_workers=num_workers) as executor:
        # Submit all tasks
        future_to_file = {
            executor.submit(process_region_file, region_file): region_file
            for region_file in region_files
        }
        
        # Process results as they complete
        for i, future in enumerate(as_completed(future_to_file), 1):
            region_file = future_to_file[future]
            try:
                result_data, r_min_x, r_min_z, r_max_x, r_max_z, chunks = future.result()
                
                # Merge results into main surface_data
                for pos, (block_name, height) in result_data.items():
                    if pos not in surface_data or height > surface_data[pos][1]:
                        surface_data[pos] = (block_name, height)
                
                # Update global bounds
                min_x = min(min_x, r_min_x)
                min_z = min(min_z, r_min_z)
                max_x = max(max_x, r_max_x)
                max_z = max(max_z, r_max_z)
                
                total_chunks += chunks
                print(f"Processed {region_file.name} ({i}/{len(region_files)}) - {chunks} chunks")
            except Exception as e:
                print(f"Error processing {region_file.name}: {e}")
    
    if not surface_data:
        print("No block data found in region files")
        return None, None
    
    t2 = time.time()
    
    print(f"\nTotal chunks processed: {total_chunks}")
    print(f"Total surface positions: {len(surface_data):,}")
    print(f"Processing time: {t2 - t1:.2f} seconds")
    
    # Convert bounds to integers
    min_x, min_z = int(min_x), int(min_z)
    max_x, max_z = int(max_x), int(max_z)
    
    print(f"World bounds: X=[{min_x}, {max_x}], Z=[{min_z}, {max_z}]")
    
    # Calculate image dimensions
    width = max_x - min_x + 1
    height = max_z - min_z + 1
    
    print(f"Image dimensions: {width}x{height} pixels")
    
    # Find height range for heightmap normalization
    heights = [h for _, h in surface_data.values()]
    min_height = min(heights)
    max_height = max(heights)
    height_range = max_height - min_height if max_height > min_height else 1
    
    print(f"Height range: Y=[{min_height}, {max_height}]")
    
    # Create images
    surface_map = np.zeros((height, width, 3), dtype=np.uint8)
    heightmap = np.zeros((height, width), dtype=np.uint8)
    
    # Fill in the data
    for (world_x, world_z), (block_name, block_height) in surface_data.items():
        # Convert world coords to image coords
        img_x = world_x - min_x
        img_y = world_z - min_z
        
        # Surface map color
        color = get_block_color(block_name)
        surface_map[img_y, img_x] = color
        
        # Heightmap value (normalized to 0-255)
        normalized_height = int(255 * (block_height - min_height) / height_range)
        heightmap[img_y, img_x] = normalized_height
    
    # Save images
    surface_map_path = chunks_folder / f"{output_prefix}_surface.png"
    heightmap_path = chunks_folder / f"{output_prefix}_heightmap.png"
    
    t3 = time.time()
    print(f"Image creation time: {t3 - t2:.2f} seconds")
    
    print(f"\nSaving surface map to {surface_map_path}...")
    Image.fromarray(surface_map, mode='RGB').save(surface_map_path)
    
    print(f"Saving heightmap to {heightmap_path}...")
    Image.fromarray(heightmap, mode='L').save(heightmap_path)
    
    # Print block color legend for common blocks found
    print("\n" + "=" * 60)
    print("BLOCK COLOR LEGEND (most common blocks):")
    print("-" * 60)
    
    block_counts: Dict[str, int] = defaultdict(int)
    for block_name, _ in surface_data.values():
        block_counts[block_name] += 1
    
    sorted_blocks = sorted(block_counts.items(), key=lambda x: -x[1])[:20]
    for block_name, count in sorted_blocks:
        color = get_block_color(block_name)
        print(f"  {block_name:40} RGB{color} ({count:,} pixels)")
    
    return surface_map_path, heightmap_path


def main():
    parser = argparse.ArgumentParser(
        description="Generate surface map and heightmap from Hytale region files"
    )
    parser.add_argument(
        "folder",
        nargs="?",
        help="Path to folder containing .region.bin files (default: Hytale default chunks folder)"
    )
    parser.add_argument(
        "-o", "--output",
        default="map",
        help="Output filename prefix (default: 'map')"
    )
    
    args = parser.parse_args()
    
    # Determine chunks folder
    if args.folder:
        chunks_folder = Path(args.folder)
    else:
        # Default Hytale path
        appdata = os.getenv('APPDATA')
        if appdata:
            chunks_folder = Path(appdata) / r'Hytale\UserData\Saves\Server\universe\worlds\default\chunks'
        else:
            print("Error: APPDATA environment variable not set and no folder specified")
            return
    
    if not chunks_folder.exists():
        print(f"Error: Folder not found: {chunks_folder}")
        print("Please specify a valid folder containing .region.bin files")
        return
    
    print("=" * 60)
    print("SURFACE MAP AND HEIGHTMAP GENERATOR")
    print("=" * 60)
    print(f"Source folder: {chunks_folder}")
    print()
    
    surface_path, height_path = generate_maps(chunks_folder, args.output)
    
    if surface_path and height_path:
        print()
        print("=" * 60)
        print("OUTPUT FILES:")
        print(f"  Surface map: {surface_path}")
        print(f"  Heightmap:   {height_path}")
        print("=" * 60)
        print("\nDone!")
    else:
        print("\nFailed to generate maps.")


if __name__ == "__main__":
    main()
